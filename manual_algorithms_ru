Документация к написанию дополнительных алгоритмических модулей

1. Общие сведения:

В любом алгоритмическом модуле должны быть как минимум:
    1.1. Структура insane_algorithm, в которой указываются название алгоритма, параметры страйпа, а также функции, которые отвечают за маппинг и создание запросов чтения-записи. То, как эта структура объявляется в модулях LRC и raid6, дает исчерпывающее представление об информации, которую там надо размещать.
    1.2. Функция маппинга, возвращающая структуру parity_places
    1.3. Функция восстановления, возвращающая структуру recover_stripe
    1.4. Функции конфигурирования, загрузки и выгрузки алгоритма. Их можно спокойно скопировать из любого готового модуля, поправив имена.

2. Структуры
    
С используемыми структурами можно ознакомиться в файле insane.h. Знать о них нужно следующее:
    2.1. В структуре parity_places хранятся адреса синдромов (номер девайса и номер сектора) данного страйпа. Переменные start_device и start_sector на данный момент нигде не используются, так что их, в принципе, можно и не высчитывать. Переменная last_block нужна для режима sequential, чтобы эмулятор знал, в какой момент при последовательной записи нужно перезаписывать синдромы.
    2.2. В структуре recover_stripe хранятся адреса блоков, которые нужно прочитать для восстановления отказавшего блока в страйпе, количество этих блоков, а также адрес блока, на который будет происходить "восстановление".
    
3. Функции
    
    3.1. Ремаппинг.
    Существует три режима работы эмулятора: sequential, random и recover. В первых двух создается блочное устройство, и при любом чтении или записи на него вызывается функция ремаппинга (основной алгоритм, возвращающий структуру parity_places). В функцию будут приходить адреса блоков, в которые хочется записать, но без учета синдромов. Например, пусть у нас есть RAID такого вида:
        
        DDDDSS
        DDDSSD
        DDSSDD
        DSSDDD
        SSDDDD
        SDDDDS
    
    Здесь D - блоки данных, S - синдромы. Если мы попробуем прочитать пятый блок данных, то в функцию ремаппинга придет не второй блок первого устройства (с пропуском синдромов), а первый блок пятого устройства. Таким образом, именно в функции ремаппинга нужно осуществить перенаправление (изменить переменные *sector и *device_number), чтобы данные были там, где следует. Это первая вещь, которая должна быть реализована в функции.
    Вообще, у функции есть 4 аргумента: insane_c *ctx (контекст, общие параметры создаваемого RAID), u64 block (номер блока на отдельном устройстве, из которых собирается RAID, служит просто для облегчения расчетов), sector_t *sector (сектор на отдельном устройстве), int *device_number (номер отдельного устройства).

    Далее, необходимо рассчитать адреса синдромов, отвечающих за блок, в который была перенаправлена запись. Эти адреса записываются в возвращаемую структуру. Кроме того, когда все синдромы будут посчитаны и записаны, в следующий элемент массива parity_places.device_number нужно записать число -1. Например, если у нас два синдрома в страйпе, то после вычислений делаем следующее:

        parity_places.device_number[2] = -1;

    Это нужно сделать, потому что эмулятор не знает заранее, сколько синдромов будут отвечать за блок. Поэтому он создает запросы, следуя по массиву, пока не встретит номер устройства -1. Таким образом, возврат синдромов -- это вторая вещь, которая должна быть реализована в функции.

    Наконец, если устройство находится в режиме sequential (это можно узнать так: ctx->io_pattern == SEQUENTIAL), то нужно определить, является ли запись, которую мы осуществляем, последней для данного страйпа, и в зависимости от этого присвоить значение булевой переменной parity_places.last_block. Таким образом в режиме sequential перезапись синдромов будет происходить только при достижении конца страйпа. Это последняя вещь, которая должна быть реализована в функции ремаппинга.

    3.2. Восстановление.
    В режиме работы recover происходит следующее: один из дисков помечается как отказавший, после чего для каждого его блока рассчитывается, что нужно прочитать для восстановления, и куда это восстановление будет происходить. Таким образом, у функции восстановления есть три аргумента: insane_c *ctx, u64 block и int device_number. После этого результаты возвращаются структурой recover_stripe. Простой пример такой функции можно посмотреть в модуле raid6.

4. Использование

После успешной сборки модуля его можно использовать точно так же, как и все остальные (процедура описана в мануале manual_ru)
